{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "ef8b52dd-ecc7-459f-b1cf-cdf6f5102f9a",
   "metadata": {},
   "source": [
    "# Eco-inspired Indicators"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cfe34499-fcdf-4524-b3cf-2f1377289dd5",
   "metadata": {},
   "source": [
    "# Instruction:\n",
    "\n",
    "## 1. Network Construction in CSV File (Input-Output Table Format):\n",
    "\n",
    "### Construct the network of flows between compartments in a CSV file in the format of an input-output table.\n",
    "### Each supply chain actor or process should be represented as a node in the CSV.\n",
    "### Ensure the CSV file is stored in a repository accessible via URL.\n",
    "### The input-output numerical data should start from cell (2, 2) in the CSV and continue to the right and down, building the table (see one of the csv files for the multilayer film as an example)\n",
    "### Node Order in CSV:\n",
    "### The last four nodes are transactions with the external environment and must represent:\n",
    "### - Fourth to last node : Virgin external resource node \n",
    "### - Third to last node : Renewable or recovered external resource node \n",
    "### - Second to last node : Dissipation node (for losses)\n",
    "### - Last node: Export node (for open-loop recovery)\n",
    "\n",
    "### Except for the last four nodes, other nodes can be in any order in the CSV file.\n",
    "\n",
    "## 2. Running the Code:\n",
    "\n",
    "### After constructing the network CSV file, execute the following code cell.\n",
    "\n",
    "### The code will prompt you for several inputs:\n",
    "\n",
    "### - URL of the CSV file containing the input-output flow network\n",
    "### - Amount of refusal flow (in the same unit as the flows in the network)\n",
    "### - Index of the consumer node (The indices start from 0 for the first column (or row) in the input-output table and continues incrementally as you move to the next column or row)\n",
    "### - Indices of source nodes directing flows to the consumer node \n",
    "### - Indices of nodes in each circularity level (if applicable)\n",
    "### - Indices of recovery processes (if applicable)\n",
    "### - Indices of nodes receiving the recovered flows from recovery processes (if applcable)\n",
    "\n",
    "### Provide accurate inputs as requested by the prompts."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "id": "7fdc1ce6-1459-46e7-99fe-5af1cd422dbf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdin",
     "output_type": "stream",
     "text": [
      "Enter the URL of the CSV file (ending in .csv):  https://raw.githubusercontent.com/FarshidNazemi/ENA/main/data/Best%20Case%20(Refuse%2BDiverse%20EoL).csv\n",
      "Enter the amount of the refusal flow:  0.8\n",
      "Enter the index of the consumer node:  2\n",
      "Enter the indices of source nodes where the flow to the consumer node is coming from (comma-separated):  1,4\n",
      "Enter the indices of nodes in Circularity level 1 (Littering) (comma-separated, leave empty if none):  \n",
      "Enter the indices of nodes in Circularity level 2 (Landfill) (comma-separated, leave empty if none):  7\n",
      "Enter the indices of nodes in Circularity level 3 (Energy Recovery, Compost) (comma-separated, leave empty if none):  \n",
      "Enter the indices of nodes in Circularity level 4 (Open-loop Recovery, Renewable) (comma-separated, leave empty if none):  6\n",
      "Enter the indices of nodes in Circularity level 5 (Refurbish, Recycle) (comma-separated, leave empty if none):  5\n",
      "Enter the indices of nodes in Circularity level 6 (Redistribute) (comma-separated, leave empty if none):  \n",
      "Enter the indices of nodes in Circularity level 7 (Reuse) (comma-separated, leave empty if none):  4\n",
      "Enter the indices of recovery processes (comma-separated, leave empty if there is none):  4,5,6\n",
      "Enter the indices of receiving processes (comma-separated, leave empty if there is none):  0,2\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1mEco-inspired Indicators:\u001b[0m\n",
      "Recovered-Renewable to Virgin ratio (R : V) = 1.7204301075268817\n",
      "Resource Consumption Efficiency (RCE) = 2.150537632096196\n",
      "Adjusted Resource Consumption efficiency (RCE_star) = 10.75268816048098\n",
      "Network Intensity (NI) = 3.4835000000000003\n",
      "Adjusted Network Intensity (NI_star) = 0.6967000000000001\n",
      "Robustness = 0.7059529566199914\n",
      "Loop Tightness (LT) = 0.5804511262775637\n",
      "Mean Circularity Level (MCL) = 0.9076465157298571\n"
     ]
    }
   ],
   "source": [
    "#Importing packages\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import math\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.special import logsumexp\n",
    "\n",
    "#CSV file URL\n",
    "csv_url = input(\"Enter the URL of the CSV file (ending in .csv): \")\n",
    "\n",
    "#Read CSV file, skip first two rows, and drop first two columns\n",
    "df = pd.read_csv(csv_url, header=None, skiprows=2)\n",
    "df = df.iloc[:, 2:]\n",
    "\n",
    "# Building the total flow matrix\n",
    "R = df.to_numpy()\n",
    "\n",
    "# Refusal flow\n",
    "F_R = float(input(\"Enter the amount of the refusal flow: \"))\n",
    "\n",
    "\n",
    "\n",
    "# Get the dimensions of the matrix\n",
    "rows, cols = R.shape\n",
    "\n",
    "# Constructing the Internal Flow Matrix (F)\n",
    "# Specify how many rows and columns to remove\n",
    "rows_to_remove = 4\n",
    "cols_to_remove = 4\n",
    "# Remove the last rows and columns\n",
    "if rows_to_remove > 0 and cols_to_remove > 0:\n",
    "    F = R[:rows - rows_to_remove, :cols - cols_to_remove]\n",
    "    \n",
    "# Consumer demand (functional unit)\n",
    "consumer_node_index = int(input(\"Enter the index of the consumer node: \"))\n",
    "# Add all flows directing to the consumer node to calculate the functional unit\n",
    "source_node_indices = input(\"Enter the indices of source nodes where the flow to the consumer node is coming from (comma-separated): \").split(\",\")\n",
    "FU = sum(F[int(index), consumer_node_index] for index in source_node_indices)\n",
    "\n",
    "# Virgin input vector (Z)\n",
    "# Get the fourth row from the end and store it in a vector\n",
    "Z = R[-4, :-4]\n",
    "\n",
    "# Recovered input vector (Z_prime)\n",
    "# Get the third row from the end and store it in a vector\n",
    "Z_prime = R[-3, :-4]\n",
    "\n",
    "# Dissipation vector (Y)\n",
    "# Get the second last column and store it in a vector\n",
    "Y = R[:, -2][:-4]\n",
    "\n",
    "# Export vector (Y_prime)\n",
    "# Get the last column and store it in a vector\n",
    "Y_prime = R[:, -1][:-4]\n",
    "\n",
    "# Number of compartments\n",
    "n = len(F)\n",
    "\n",
    "# Total boundary input\n",
    "TBI = np.sum(Z) + np.sum(Z_prime)\n",
    "\n",
    "# Total Input (Output) Throughflows\n",
    "T_i = np.sum(F, axis=0) + Z + Z_prime\n",
    "\n",
    "# Flow Analysis (identifies non-dimensional flow intensities along indirect pathways)\n",
    "epsilon = 1e-10\n",
    "G = F / (T_i + epsilon)\n",
    "\n",
    "# Dimensionless Integral intensities matrix\n",
    "I = np.identity(n, dtype='float64')\n",
    "N = np.linalg.inv(I - G)\n",
    "\n",
    "# Development capacity\n",
    "DC = 0.0\n",
    "for i in range(len(R)):\n",
    "    for j in range(len(R)):\n",
    "        if i != j:\n",
    "            DC += -(R[i, j] * np.log2(R[i, j] / np.sum(R) + epsilon))\n",
    "\n",
    "# Ascendency\n",
    "ASC = 0.0\n",
    "for i in range(len(R)):\n",
    "    for j in range(len(R)):\n",
    "        if i != j:\n",
    "            numerator = R[i, j]\n",
    "            denominator = (np.sum(R[i, :]) + epsilon) * (np.sum(R[:, j]) + epsilon)\n",
    "            ASC += numerator * np.log2((numerator * np.sum(R) / denominator) + epsilon)\n",
    "\n",
    "# Redundancy\n",
    "PHI = 0.0\n",
    "for i in range(len(R)):\n",
    "    for j in range(len(R)):\n",
    "        if i != j:\n",
    "            numerator = R[i, j]\n",
    "            denominator = (np.sum(R[i, :]) + epsilon) * (np.sum(R[:, j]) + epsilon)\n",
    "            PHI += -numerator * np.log2((numerator ** 2 / denominator) + epsilon)\n",
    "\n",
    "# Ratio of ascendency to development capacity\n",
    "R_ASC = ASC / DC\n",
    "\n",
    "# Total System Throughflow\n",
    "TST_flow = np.sum(F)\n",
    "\n",
    "# Eco-inspired metrics\n",
    "\n",
    "# Network Intensity\n",
    "NI = TST_flow / FU\n",
    "\n",
    "# Adjusted Network Intensity\n",
    "NI_star = TST_flow / (FU + F_R)\n",
    "\n",
    "# Robustness\n",
    "ecological_resilience = -R_ASC * math.log(R_ASC)\n",
    "Robustness = ecological_resilience / 0.3678\n",
    "\n",
    "# Mean Circularity Level (MCL)\n",
    "m = 8\n",
    "Num = 0.0\n",
    "Denom = 0.0\n",
    "\n",
    "# Circularity Levels Vector\n",
    "CLi = [1,2,3,4,5,6,7,8]\n",
    "\n",
    "# Vector of flows in each circularity level\n",
    "BLi = []\n",
    "\n",
    "\n",
    "# Prompt user for indices of nodes in each circularity level with descriptions\n",
    "circularity_levels_description = [\n",
    "    \"Circularity level 1 (Littering)\",\n",
    "    \"Circularity level 2 (Landfill)\",\n",
    "    \"Circularity level 3 (Energy Recovery, Compost)\",\n",
    "    \"Circularity level 4 (Open-loop Recovery, Renewable)\",\n",
    "    \"Circularity level 5 (Refurbish, Recycle)\",\n",
    "    \"Circularity level 6 (Redistribute)\",\n",
    "    \"Circularity level 7 (Reuse)\"\n",
    "]\n",
    "\n",
    "BLi = []\n",
    "for i in range(m - 1):\n",
    "    indices = input(f\"Enter the indices of nodes in {circularity_levels_description[i]} (comma-separated, leave empty if none): \").split(\",\")\n",
    "    if indices == ['']:\n",
    "        BLi.append(0)\n",
    "    else:\n",
    "        BLi.append(sum(T_i[int(index)] for index in indices))\n",
    "\n",
    "BLi.append(F_R)\n",
    "\n",
    "for i in range(m):\n",
    "    Num += BLi[i] * CLi[i]\n",
    "    Denom += BLi[i]\n",
    "MCL = Num / Denom\n",
    "MCL = (MCL - CLi[0]) / (CLi[-1] - 1)  # Normalizing\n",
    "\n",
    "# Calculate R:V ratio\n",
    "recovery_process_indices = input(\"Enter the indices of recovery processes (comma-separated, leave empty if there is none): \").split(\",\")\n",
    "receiving_process_indices = input(\"Enter the indices of processes receiving the recovered flows in a closed-loop manner (comma-separated, leave empty if there is none): \").split(\",\")\n",
    "\n",
    "if recovery_process_indices == ['']:\n",
    "    numerator = 0\n",
    "else:\n",
    "    numerator = (\n",
    "        sum(F[int(index1), int(index2)] for index1 in recovery_process_indices for index2 in receiving_process_indices) +\n",
    "        sum(Y_prime[int(index)] for index in recovery_process_indices) +\n",
    "        sum(Z_prime[int(index)] for index in recovery_process_indices)\n",
    "    )\n",
    "\n",
    "D_H = numerator / np.sum(Z)\n",
    "\n",
    "\n",
    "R_V = numerator / np.sum(Z)\n",
    "\n",
    "# Loop Tightness\n",
    "FU_c = (N[consumer_node_index, consumer_node_index] - 1) / (N[consumer_node_index, consumer_node_index] + epsilon) * T_i[consumer_node_index]\n",
    "LT = FU_c / FU\n",
    "\n",
    "# Resource Consumption Efficiency\n",
    "RCE = FU / (np.sum(Z) + epsilon)\n",
    "\n",
    "# Adjusted Resource Consumption Efficiency\n",
    "RCE_star = (FU + F_R) / (np.sum(Z) + epsilon)\n",
    "\n",
    "# Print eco-inspired indicators\n",
    "print(\"\\033[1mEco-inspired Indicators:\\033[0m\")\n",
    "print(\"Recovered-Renewable to Virgin ratio (R : V) =\", R_V)\n",
    "print(\"Resource Consumption Efficiency (RCE) =\", RCE)\n",
    "print(\"Adjusted Resource Consumption efficiency (RCE_star) =\", RCE_star)\n",
    "print(\"Network Intensity (NI) =\", NI)\n",
    "print(\"Adjusted Network Intensity (NI_star) =\", NI_star)\n",
    "print(\"Robustness =\", Robustness)\n",
    "print(\"Loop Tightness (LT) =\", LT)\n",
    "print(\"Mean Circularity Level (MCL) =\", MCL)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "887acdb3-d304-4e8f-a697-87d25d729f83",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.13"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
